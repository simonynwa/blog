<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>simonynwa&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-12T05:07:17.992Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Simon Ding</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习笔记（2）</title>
    <link href="http://example.com/2024/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    <id>http://example.com/2024/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/</id>
    <published>2024-10-10T15:10:40.000Z</published>
    <updated>2024-10-12T05:07:17.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-K-means"><a href="#一-K-means" class="headerlink" title="一. K-means"></a>一. K-means</h3><h4 id="1-简述k-means流程"><a href="#1-简述k-means流程" class="headerlink" title="1. 简述k-means流程"></a>1. 简述k-means流程</h4><p>（1）适当选择c个类的初始中心；<br>（2）在第k次迭代中，对任意一个样本，求其到c各中心的距离，将该样本归到距离最短的那个中心所在的类；<br>（3）利用均值等方法更新该类的中心值；<br>（4）对于所有的C个聚类中心，如果利用（2）（3）的迭代法更新后，值保持不变，则迭代结束；否则继续迭代。</p><h4 id="2-K—-means对异常值是否敏感，为什么？"><a href="#2-K—-means对异常值是否敏感，为什么？" class="headerlink" title="2. K— means对异常值是否敏感，为什么？"></a>2. K— means对异常值是否敏感，为什么？</h4><p>K-means对异常值<strong>较为敏感</strong>，因为一个集合内的元素<strong>均值易受到一个极大值的影响</strong>。当存在异常值的情况下，均值所计算出来的中心位置很可能不能够反映真实的类别中心。</p><h4 id="3-如何评估聚类效果？"><a href="#3-如何评估聚类效果？" class="headerlink" title="3. 如何评估聚类效果？"></a>3. 如何评估聚类效果？</h4><p>紧凑度(类内)和分离度(类间)。聚类质量：因为是无监督学习，所以一般通过评估类的分离情况来决定聚类质量。类内越紧密，类间距离越大则质量越高。</p><h4 id="4-超参数k如何选择？"><a href="#4-超参数k如何选择？" class="headerlink" title="4. 超参数k如何选择？"></a>4. 超参数k如何选择？</h4><p>手肘法的核心指标是SSE(sum of the squared errors，误差平方和)<br>$$\large SSE &#x3D; \sum_{i&#x3D;1}^{k}\sum_{p \in C_i}|p-m_i|^2$$<br>其中，Ci是第i个簇，p是Ci中的样本点，mi是Ci的质心（Ci中所有样本的均值），SSE是所有样本的聚类误差，代表了聚类效果的好坏。</p><p> 手肘法的核心思想是：随着聚类数k的增大，样本划分会更加精细，每个簇的聚合程度会逐渐提高，那么误差平方和SSE自然会逐渐变小。并且，当k小于真实聚类数时，由于k的增大会大幅增加每个簇的聚合程度，故SSE的下降幅度会很大，而当k到达真实聚类数时，再增加k所得到的聚合程度回报会迅速变小，所以SSE的下降幅度会骤减，然后随着k值的继续增大而趋于平缓，也就是说SSE和k的关系图是一个手肘的形状，而这个肘部对应的k值就是数据的真实聚类数。当然，这也是该方法被称为手肘法的原因。</p><h4 id="5-K-means的优缺点"><a href="#5-K-means的优缺点" class="headerlink" title="5. K-means的优缺点"></a>5. K-means的优缺点</h4><p>优点：</p><p>算法简单，容易理解，在某些情况下聚类效果不错；</p><p>处理大数据集的时候，该算法可以保证较好的伸缩性——即稍作改进即可以处理大数据集；</p><p>当数据簇近似于高斯分布时，效果非常不错；</p><p>算法复杂度低——时间复杂度为O（nkt），其中n为样本数，k为类别数，t为迭代数。</p><p>缺点：</p><p>k值需要人为设定，不同的k值得到的结果不一样；</p><p>对初始的类别中心敏感，不同选取方法得到的结果不一样；</p><p>对异常值敏感；</p><p>一个样本只能归为一类，不适合做单样本多标签分类任务；</p><h3 id="二-KNN"><a href="#二-KNN" class="headerlink" title="二. KNN"></a>二. KNN</h3><h4 id="1-简述KNN"><a href="#1-简述KNN" class="headerlink" title="1. 简述KNN"></a>1. 简述KNN</h4><ol><li><p>计算已知类别数据集中的点与当前点之间的距离；</p></li><li><p>按照距离递增次序排序；</p></li><li><p>选取与当前点距离最小的k个点；</p></li><li><p>确定前k个点所在类别的出现频率；</p></li><li><p>返回前k个点所出现频率最高的类别作为当前点的预测分类。</p></li></ol><h4 id="2-KNN和K-means的相似和区别"><a href="#2-KNN和K-means的相似和区别" class="headerlink" title="2. KNN和K-means的相似和区别"></a>2. KNN和K-means的相似和区别</h4><p>!(1)[1.png]</p><h3 id="三-SVM"><a href="#三-SVM" class="headerlink" title="三. SVM"></a>三. SVM</h3><h4 id="1-简述SVM原理"><a href="#1-简述SVM原理" class="headerlink" title="1. 简述SVM原理"></a>1. 简述SVM原理</h4><p>Support Vector Machine 支持向量机，主要用于解决分类问题，属于有监督学习算法的一种。</p><p>!(2)[2.png]</p><p>在保证决策面方向不变且不会出现错分样本的情况下移动决策面，会在<strong>原来的决策面两侧找到两个极限位置（越过该位置就会产生错分现象）</strong>，如虚线所示。虚线的位置由决策面的方向和距离原决策面最近的几个样本的位置决定。而这两条平行虚线正中间的分界线就是在保持当前决策面方向不变的前提下的最优决策面。<strong>两条虚线之间的垂直距离就是这个最优决策面对应的分类间隔</strong> 显然每一个可能把数据集正确分开的方向都有一个最优决策面（有些方向无论如何移动决策面的位置也不可能将两类样本完全分开），而不同方向的最优决策面的分类间隔通常是不同的，那个具有“最大间隔”的决策面就是SVM要寻找的最优解。而这个真正的最优解对应的两侧虚线所穿过的样本点，就是SVM中的支持样本点，称为“支持向量”。对于图1中的数据，A决策面就是SVM寻找的最优解，而相应的三个位于虚线上的样本点在坐标系中对应的向量就叫做支持向量。</p><p>SVM是一种二分类模型，它的基本模型是在特征空间中寻找间隔最大化的分离超平面的线性分类器。</p><ul><li>当训练样本线性可分时，通过硬间隔最大化，学习一个线性分类器，即线性可分支持向量机。</li><li>当训练数据近似线性可分时，引入松弛变量，通过软间隔最大化，学习一个线性分类器，即线性支持向量机。</li><li>当训练数据线性不可分时，通过使用核技巧和软间隔最大化，学习非线性支持向量机。</li></ul><h4 id="2-SVM大致过程"><a href="#2-SVM大致过程" class="headerlink" title="2. SVM大致过程"></a>2. SVM大致过程</h4><p>设立两个超平面函数，并用函数表示他们之间的距离关系。</p><p>将求解支持平面最大距离的问题转化为凸优化问题，因为我们有了我们的要求解的距离函数，但是此时该函数需要服从一定的情况（就是两个面不能越过支撑点，该约束条件明显是一个不等式，所以用KKT条件来做优化，如果是等式约束就用拉格朗日算子来做优化）。</p><p>对式子求梯度，并且当梯度为0时，该式可以取得最大值。</p><h4 id="3-SVM为什么采用间隔最大化"><a href="#3-SVM为什么采用间隔最大化" class="headerlink" title="3. SVM为什么采用间隔最大化"></a>3. SVM为什么采用间隔最大化</h4><p>当训练数据线性可分时，存在无穷个分离超平面可以将两类数据正确分开。感知机利用误分类最小策略，求得分离超平面，不过次时代解有无穷多个。线性可分支持向量机利用间隔最大化求得最有分离超平面，这时解是唯一的。另一方面，此时的分隔超平面所产生的分类结果是最鲁棒的。对未知实例的泛化能力最强。可以借此机会阐述一下几何间隔以及函数间隔的关系。</p><h4 id="4-SVM为什么引入核函数"><a href="#4-SVM为什么引入核函数" class="headerlink" title="4. SVM为什么引入核函数"></a>4. SVM为什么引入核函数</h4><p>当样本在原始空间线性不可分时，可将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分。而引入这样的映射后，无需求解真实的映射函数，只需要知道其核函数：<br>$$\large K(x,y) &#x3D; &lt;\phi(x), \phi(y)&gt;$$<br>即在特征空间内的内积等于它们在原始样本空间中通过核函数K计算的结果。</p><h4 id="5-SVM核函数之间的区别"><a href="#5-SVM核函数之间的区别" class="headerlink" title="5. SVM核函数之间的区别"></a>5. SVM核函数之间的区别</h4><p>一般选择线性核和高斯核（RBF核）。</p><p>线性核：主要用于线性可分的情形，参数少，速度快，对于一般数据，分类效果已经很理想了。</p><p>RBF核：主要用于线性不可分的情形，参数多，分裂结果非常依赖于参数。有很多人是通过训练数据的交叉验证来寻找合适的参数，不过这个过程比较耗时。</p><p>如果Feature的数量很大，跟样本数量差不多，选择线性核的SVM，反之选择RBF核。</p><h4 id="6-SVM优点和缺点"><a href="#6-SVM优点和缺点" class="headerlink" title="6.SVM优点和缺点"></a>6.SVM优点和缺点</h4><p>优点：</p><ol><li>它基于结构风险最小化原则，这样就避免了过学习问题，泛化能力强。</li><li>它是一个凸优化问题，因此局部最优解一定是全局最优解。</li></ol><p>缺点：</p><ol><li>对缺失数据敏感</li><li>对参数和核函数的选择敏感</li></ol><h3 id="四-决策树"><a href="#四-决策树" class="headerlink" title="四. 决策树"></a>四. 决策树</h3><h4 id="1-简述决策树的构建过程"><a href="#1-简述决策树的构建过程" class="headerlink" title="1. 简述决策树的构建过程"></a>1. 简述决策树的构建过程</h4><p>步骤1：将所有的特征看成一个一个的节点，eg（拥有房产，婚姻状态，年收入）</p><p>步骤2：将特征按不同属性分割（比如年龄这个特征：可以按老中青三个属性来划分），然后求出不同特征的信息增益&#x2F;信息增益率&#x2F;gini系数等，不同的树取不同的值。</p><p>步骤3：使用第二步遍历所有特征，选择出最优的特征，以及该特征的最优的划分方式，得出最终的子节点N1、 N2….Nm。</p><p>步骤4：对子节点N1、N2….Nm分别继续执行2-3步，直到每个最终的子节点都足够“纯”。</p><p>如果下一次该节点选出来的那一个属性是刚刚其父节点分裂时用过的属性，则该节点已经达到了叶子节点，无须继续分裂了。</p><h4 id="2-ID3决策树与C4-5决策树的区别"><a href="#2-ID3决策树与C4-5决策树的区别" class="headerlink" title="2.  ID3决策树与C4.5决策树的区别"></a>2.  ID3决策树与C4.5决策树的区别</h4><p>ID3和5算法均只适合在小规模数据集上使用。</p><p>ID3和5算法都是单变量决策树。当属性值取值比较多的时候，最好考虑C4.5算法，ID3得出的效果会比较差。 决策树分类一般情况只适合小数据量的情况(数据可以放内存) CART算法是三种算法中最常用的。</p><h4 id="3-ID3算法和CART算法"><a href="#3-ID3算法和CART算法" class="headerlink" title="3. ID3算法和CART算法"></a>3. ID3算法和CART算法</h4><p>ID3算法：</p><ol><li>对当前例子集合，计算属性的信息增益</li><li>选择信息增益大的属性A</li><li>把在A处取值相同的例子归于同一子集，A取几个值就得几个子集</li><li>一次对每种取值情况下的子集，返回1递归调用建树算法</li><li>若子集中只含有单个属性，则分值为叶子节点，判断其属性值并标上相应的符号，然后返回调用处。</li></ol><p>CART<br>CART分类回归树是一种典型的二叉决策树，可以做分类或者回归。如果待预测结果是离散型数据，则CART生成分类决策树；如果待预测结果是连续型数据，则CART生成回归决策树。</p><p>C4.5</p><p>C4.5是ID3的继承者，相对于ID3算法，C4.5算法的改进主要有：</p><p>●增加了对连续特征属性的处理，通过排序连续属性值并挑选阈值，将连续特征属性值划分为高于阈值的属性和小于或等于阈值的属性。</p><p>●增加了对属性值缺失的训练数据的处理。</p><p>●挑选特征属性依据信息增益率，而不是信息增益。</p><p>●创建树后进行修剪，试图通过用叶子节点进行替换来删除那些没有帮助的分支。</p><h4 id="4-决策树的优缺点："><a href="#4-决策树的优缺点：" class="headerlink" title="4. 决策树的优缺点："></a>4. 决策树的优缺点：</h4><p>优点:</p><p>(1)速度快: 计算量相对较小, 且容易转化成分类规则. 只要沿着树根向下一直走到叶, 沿途的分裂条件就能够唯一确定一条分类的谓词.</p><p>(2)准确性高: 挖掘出来的分类规则准确性高, 便于理解, 决策树可以清晰的显示哪些字段比较重要, 即可以生成可以理解的规则.</p><p>(3)可以处理连续和种类字段</p><p>(4)不需要任何领域知识和参数假设</p><p>(5)适合高维数据</p><p>缺点:</p><p>(1)对于各类别样本数量不一致的数据, 信息增益偏向于那些更多数值的特征</p><p>(2)容易过拟合</p><p>(3)忽略属性之间的相关性。</p><h3 id="五-神经网络基础"><a href="#五-神经网络基础" class="headerlink" title="五.  神经网络基础"></a>五.  神经网络基础</h3><h4 id="1-为什么必须在神经网络中引入非线性"><a href="#1-为什么必须在神经网络中引入非线性" class="headerlink" title="1. 为什么必须在神经网络中引入非线性"></a>1. 为什么必须在神经网络中引入非线性</h4><p>如果不用激励函数（其实相当于激励函数是f(x) &#x3D; x），在这种情况下你每一层输出都是上层输入的线性函数，很容易验证，无论你神经网络有多少层，输出都是输入的线性组合，与没有隐藏层效果相当。</p><h4 id="2-Relu的优缺点"><a href="#2-Relu的优缺点" class="headerlink" title="2. Relu的优缺点"></a>2. Relu的优缺点</h4><p>有的负值都变为0，而正值不变，这种操作被成为单侧抑制。正因为有了这单侧抑制，才使得神经网络中的神经元也具有了<strong>稀疏激活性</strong>。</p><p>使用 ReLU 得到的 SGD 的收敛速度会比 sigmoid&#x2F;tanh 快很多; 计算复杂度低，不需要进行指数运算；</p><p>训练的时候很”脆弱”，很容易就”die”了; ReLU不会对数据做幅度压缩，所以数据的幅度会随着模型层数的增加不断扩张</p><h4 id="3-四种归一化"><a href="#3-四种归一化" class="headerlink" title="3. 四种归一化"></a>3. 四种归一化</h4><p>为什么要归一化：神经网络学习过程的本质就是为了学习数据分布，如果我们没有做归一化处理，那么每一批次训练数据的分布不一样，从大的方向上看，神经网络则需要在这多个分布中找到平衡点，从小的方向上看，由于每层网络输入数据分布在不断变化，这也会导致每层网络在找平衡点，显然，神经网络就很难收敛了。当然，如果我们只是对输入的数据进行归一化处理（比如将输入的图像除以255，将其归到0到1之间），只能保证输入层数据分布是一样的，并不能保证每层网络输入数据分布是一样的，所以也需要在神经网络的中间层加入归一化处理。神经网络学习过程本质上就是为了学习数据分布，如果训练数据与测试数据的分布不同，网络的泛化能力就会严重降低。（<strong>任何层都需要归一化</strong>）</p><h4 id="4-什么是端到端学习（end-to-end）"><a href="#4-什么是端到端学习（end-to-end）" class="headerlink" title="4. 什么是端到端学习（end-to-end）"></a>4. 什么是端到端学习（end-to-end）</h4><p>端到端学习是一种解决问题的思路，与之对应的是多步骤解决问题，也就是将一个问题拆分为多个步骤分步解决，而端到端是由输入端的数据直接得到输出端的结果。</p><h4 id="5-AlexNet，VGG，GoogleNet，ResNet等网络之间的区别是什么"><a href="#5-AlexNet，VGG，GoogleNet，ResNet等网络之间的区别是什么" class="headerlink" title="5. AlexNet，VGG，GoogleNet，ResNet等网络之间的区别是什么?"></a>5. AlexNet，VGG，GoogleNet，ResNet等网络之间的区别是什么?</h4><p>Alexnet：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一-K-means&quot;&gt;&lt;a href=&quot;#一-K-means&quot; class=&quot;headerlink&quot; title=&quot;一. K-means&quot;&gt;&lt;/a&gt;一. K-means&lt;/h3&gt;&lt;h4 id=&quot;1-简述k-means流程&quot;&gt;&lt;a href=&quot;#1-简述k-mean</summary>
      
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记（1）</title>
    <link href="http://example.com/2024/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://example.com/2024/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</id>
    <published>2024-10-10T15:10:23.000Z</published>
    <updated>2024-10-10T15:37:43.095Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-特征工程"><a href="#一-特征工程" class="headerlink" title="一. 特征工程"></a>一. 特征工程</h3><h4 id="1-为什么要对特征做归一化处理"><a href="#1-为什么要对特征做归一化处理" class="headerlink" title="1. 为什么要对特征做归一化处理"></a>1. 为什么要对特征做归一化处理</h4><p>Feature scaling，特征归一化，标准化。特征间的单位（尺度）可能不同，尺度大的特征会起决定性作用。为了消除单位和尺度的影响，以对每维特征同等看待，需要对其进行归一化。</p><h4 id="2-什么是组合特征？如何处理高维组合特征？"><a href="#2-什么是组合特征？如何处理高维组合特征？" class="headerlink" title="2. 什么是组合特征？如何处理高维组合特征？"></a>2. 什么是组合特征？如何处理高维组合特征？</h4><p>为了提高复杂关系的拟合能力，在特征工程中经常会把一阶离散特征两两组合，构成高阶组合特征。可以采取降维，矩阵分解或者特征筛选的方法得到具备绝大部分信息的几个特征进行训练。</p><h4 id="3-比较欧式距离和曼哈顿距离、"><a href="#3-比较欧式距离和曼哈顿距离、" class="headerlink" title="3. 比较欧式距离和曼哈顿距离、"></a>3. 比较欧式距离和曼哈顿距离、</h4><p>欧式距离：欧几里得距离，就是平方和开根号。欧式距离越小，两个向量的相似度越大。<br>曼哈顿距离：$|x1-x2|+|y1-y2|$<br>切比雪夫距离：$max(|x1-x2|, |y1-y2|)$</p><h4 id="4-什么是余弦相似度？为什么有些场景下使用余弦相似度？"><a href="#4-什么是余弦相似度？为什么有些场景下使用余弦相似度？" class="headerlink" title="4. 什么是余弦相似度？为什么有些场景下使用余弦相似度？"></a>4. 什么是余弦相似度？为什么有些场景下使用余弦相似度？</h4><p>两个向量夹角的余弦，关注的是向量之间的角度关系，并不关心它们的绝对大小,余弦相似度依然符合“相同为1，正交为0，相反为-1”的性质。<br>欧式距离衡量空间点的直线距离，余弦距离衡量点在空间的方向差异。欧式距离体现的数值上的绝对差异，而余弦距离体现方向上的相对差异。</p><h4 id="5-one-hot的作用是什么？为什么不能直接用数字来表示？"><a href="#5-one-hot的作用是什么？为什么不能直接用数字来表示？" class="headerlink" title="5. one-hot的作用是什么？为什么不能直接用数字来表示？"></a>5. one-hot的作用是什么？为什么不能直接用数字来表示？</h4><p>One-Hot编码是分类变量作为二进制向量的表示。这首先要求将分类值映射到整数值。然后，每个整数值被表示为二进制向量，除了整数的索引之外，它都是零值，它被标记为1。直接使用数字会给将人工误差而导致的假设引入到类别特征中，比如类别之间的大小关系，以及差异关系等等，且直接用数字不是连续的。</p><h3 id="二-模型评估"><a href="#二-模型评估" class="headerlink" title="二. 模型评估"></a>二. 模型评估</h3><h4 id="1-过拟合和欠拟合是啥？具体表现是啥？"><a href="#1-过拟合和欠拟合是啥？具体表现是啥？" class="headerlink" title="1. 过拟合和欠拟合是啥？具体表现是啥？"></a>1. 过拟合和欠拟合是啥？具体表现是啥？</h4><p>  过拟合：训练集上表现很好，测试集上表现很差。<br>  欠拟合：训练集上表现很差。欠拟合会导致高bias，过拟合会导致高variance，所以模型需要在bias和variance之间做出一个权衡。</p><h4 id="2-降低过拟合和欠拟合的方法"><a href="#2-降低过拟合和欠拟合的方法" class="headerlink" title="2. 降低过拟合和欠拟合的方法"></a>2. 降低过拟合和欠拟合的方法</h4><ol><li>解决欠拟合的方法：</li></ol><ul><li>增加新特征，可以考虑加入特征组合，高次特征，来增大假设空间。</li><li>尝试非线性模型，比如核SVM，决策树，DNN</li><li>如果有正则项可以调小正则项参数$\lambda$</li><li>Boosting, 比如Gradient Boosting、</li></ul><ol start="2"><li>解决过拟合的方法：</li></ol><ul><li>减少特征数量</li><li>正则化</li></ul><h4 id="3-L1和L2正则分别服从什么分布"><a href="#3-L1和L2正则分别服从什么分布" class="headerlink" title="3. L1和L2正则分别服从什么分布"></a>3. L1和L2正则分别服从什么分布</h4><p>L1是拉普拉斯分布，L2是高斯分布。范数是一个函数，是矢量空间内的所有矢量赋予非零的正<strong>长度</strong>或<strong>大小</strong>。<br>$$||x||<em>p &#x3D; (\sum^n</em>{i&#x3D;1}|x_i|^p)^{1&#x2F;p}$$<br>L1范数：当p&#x3D;1时，是L1范数，其表示某个向量中所有元素**绝对值的和。</p><p>L2范数：当p&#x3D;2时，是L2范数， 表示某个向量中所有元素平方和再开根， 也就是欧几里得距离公式。</p><h4 id="4-对于树形结构为什么不用归一化？"><a href="#4-对于树形结构为什么不用归一化？" class="headerlink" title="4. 对于树形结构为什么不用归一化？"></a>4. 对于树形结构为什么不用归一化？</h4><p>因为数值缩放不影响分裂点位置，对树模型的结构不造成影响。按照特征值进行排序的，排序的顺序不变，那么所属的分支以及分裂点就不会有不同。而且，树模型是不能进行梯度下降的，<strong>因为构建树模型（回归树）寻找最优点时是通过寻找最优分裂点完成的，因此树模型是阶跃的，阶跃点是不可导的，并且求导没意义，也就不需要归一化。</strong> 树型结构不关心变量的值，只关心变量分布以及变量之间的条件概率。</p><h4 id="5-什么是数据不平衡？如何解决？"><a href="#5-什么是数据不平衡？如何解决？" class="headerlink" title="5. 什么是数据不平衡？如何解决？"></a>5. 什么是数据不平衡？如何解决？</h4><p>数据不平衡主要存在于有监督机器学习任务中。当遇到数据不平衡时，以总体分类准确率为学习目标的传统分类算法会过多地关注多数类，从而使得少数样本的分类性能下降。绝大多数常见的机器学习算法对于不平衡数据集都不能很好地工作。</p><h4 id="6-bias，variance，error"><a href="#6-bias，variance，error" class="headerlink" title="6. bias，variance，error"></a>6. bias，variance，error</h4><p>Error &#x3D; Bias + Variance + Noise，偏差（bias）指的是模型的预测值与真实值之间的系统性误差。方差（variance）指的是模型对训练数据的敏感程度，也就是模型在不同训练数据集上的表现差异。噪声（noise）指的是数据中不可避免的随机误差，它通常来自测量误差、数据不完整或数据中的内在随机性。噪声是数据固有的一部分，与模型无关。</p><h3 id="三-线性回归与逻辑回归"><a href="#三-线性回归与逻辑回归" class="headerlink" title="三. 线性回归与逻辑回归"></a>三. 线性回归与逻辑回归</h3><h4 id="1-logistic回归公式是什么？"><a href="#1-logistic回归公式是什么？" class="headerlink" title="1. logistic回归公式是什么？"></a>1. logistic回归公式是什么？</h4><p>逻辑回归虽然名字里面有回归，但是主要用来解决分类问题。logistic-regression就是一个线性回归经过阶跃函数的处理，变成一个二项分类器，输出结果只能是0，1的条件概率的大小，其实是一种概率模型。<br>$$\large<br>P(Y&#x3D;1|x) &#x3D; \frac{1}{1+e^{-(w^Tx+b)}}<br>$$</p><p>也就是说，输出 Y&#x3D;1 的对数几率是由输入 x 的<strong>线性函数</strong>表示的模型，这就是<strong>逻辑回归模型</strong>。当 WT+b 的值越接近正无穷， P(Y&#x3D;1|x) 概率值也就越接近 1。因此<strong>逻辑回归的思路</strong>是，先拟合决策边界(不局限于线性，还可以是多项式)，再建立这个边界与分类的概率联系，从而得到了二分类情况下的概率。</p><h4 id="2-逻辑回归和线性回归，有何异同？"><a href="#2-逻辑回归和线性回归，有何异同？" class="headerlink" title="2. 逻辑回归和线性回归，有何异同？"></a>2. 逻辑回归和线性回归，有何异同？</h4><p>逻辑回归与线性回归都属于广义线性回归模型, 逻辑回归处理的是分类问题，线性回归处理的是回归问题，这是两者最本质的区别。线性回归中使用的是最小化平方误差损失函数（线性回归就是y&#x3D;WT+b，损失函数用MSE）</p><h4 id="3-逻辑回归的损失函数"><a href="#3-逻辑回归的损失函数" class="headerlink" title="3. 逻辑回归的损失函数"></a>3. 逻辑回归的损失函数</h4><p>极大似然估计法: 就是利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值！那么既然事情已经发生了，为什么不让这个出现的结果的可能性最大呢？这也就是最大似然估计的核心。</p><p>白球黑球不知道有多少，取100次有放回，70是白，30黑，那么采取的方法是让这个样本结果出现的可能性最大，也就是使得p^70(1-p)^30值最大，那么我们就可以看成是p的方程，求导即可！50，50。20，80等无数种组合都可以，为什么要70和30呢？因为是已经发生的事情了，就让他作为可能性最大的结果。</p><h4 id="4-逻辑回归处理多分类标签问题时，一般怎么做？"><a href="#4-逻辑回归处理多分类标签问题时，一般怎么做？" class="headerlink" title="4. 逻辑回归处理多分类标签问题时，一般怎么做？"></a>4. 逻辑回归处理多分类标签问题时，一般怎么做？</h4><p>如果一个样本只对应于一个标签，我们可以假设每个样本属于不同标签的概率服从于几何分布，使用多项逻辑回归（ Softmax Regression ) 来进行分类。当存在样本可能居于多个标签的情况时，我们可以训练 k个二分类的逻辑回归分类器。第l个分类器用以区分每个样本是否可以归为第i类，训练该分类器时，需要把标签重新整理为“第 i 类标签” 与“非第i类标签”两类。 遇过这样的办法，我们就解决了每个样本可能拥有多个标签的情况。</p><p>多项逻辑回归:<br>    $$\large P(Y&#x3D;k|x) &#x3D; \frac{e^{w_k^Tx + b_k}}{\sum_{j&#x3D;1}^Ke^{w_j^Tx+b_j}}$$</p><h3 id="四-朴素贝叶斯模型"><a href="#四-朴素贝叶斯模型" class="headerlink" title="四. 朴素贝叶斯模型"></a>四. 朴素贝叶斯模型</h3><h4 id="1-全概率公式-贝叶斯公式"><a href="#1-全概率公式-贝叶斯公式" class="headerlink" title="1. 全概率公式 &amp; 贝叶斯公式"></a>1. 全概率公式 &amp; 贝叶斯公式</h4><p>$$\large P(A|B) &#x3D; \frac{P(B|A)P(A)}{\sum_{i&#x3D;1}^nP(B|A_i)P(A_i)}$$</p><p>贝叶斯：$$P(A|B) &#x3D; \frac{P(B|A)P(A)}{P(B)}$$<br>全概率：<br>$$P(A) &#x3D; \sum_{i&#x3D;1}^nP(A|B_i)$$</p><h4 id="2-为什么叫朴素贝叶斯？"><a href="#2-为什么叫朴素贝叶斯？" class="headerlink" title="2. 为什么叫朴素贝叶斯？"></a>2. 为什么叫朴素贝叶斯？</h4><p>因为<strong>分母对于所有类别为常数</strong>，我们只要将分子最大化即可。又因为各特征属性是条件独立的(朴素贝叶斯为什么“朴素”的原因)。</p><h4 id="3-工作流程？"><a href="#3-工作流程？" class="headerlink" title="3. 工作流程？"></a>3. 工作流程？</h4><p>对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。通俗来说，就好比这么个道理，你在街上看到一个黑人，我问你你猜这哥们哪里来的，你十有八九猜非洲。为什么呢？因为黑人中非洲人的比率最高，当然人家也可能是美洲人或亚洲人，但在没有其它可用信息下，我们会选择条件概率最大的类别，这就是朴素贝叶斯的思想基础。</p><h4 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h4><p>优点：</p><ol><li><p>易于实现和理解：朴素贝叶斯算法基于简单的概率论和统计学知识，易于实现和理解。</p></li><li><p>高效性：朴素贝叶斯算法的计算成本相对较低，对于大规模数据集的训练和分类具有很高的效率。</p></li><li><p>对缺失数据不敏感：在朴素贝叶斯算法中，某个特征值的缺失不会影响整个实例的分类。</p></li><li><p>稳健性：在数据分布符合模型假设的情况下，朴素贝叶斯分类器通常表现出较好的分类性能。</p></li><li><p>适用于多分类问题：朴素贝叶斯算法可以处理多分类问题，并且可以增量式学习。</p></li></ol><p>缺点：</p><ol><li><p>独立性假设：朴素贝叶斯算法假设特征之间是相互独立的，这在现实中往往不成立。这种假设可能导致算法在特征相关性较高的情况下表现不佳。</p></li><li><p>对输入数据的表达形式敏感：朴素贝叶斯算法的性能受到输入数据表达形式的影响。如果数据的预处理或特征选择不合适，可能会影响分类效果。</p></li><li><p>对参数估计敏感：朴素贝叶斯算法的性能也依赖于参数估计的准确性。如果样本数据不足以准确估计参数，分类器的性能可能会受到影响。</p></li></ol><h3 id="六-集成学习"><a href="#六-集成学习" class="headerlink" title="六. 集成学习"></a>六. 集成学习</h3><h4 id="1-什么是集成学习算法？"><a href="#1-什么是集成学习算法？" class="headerlink" title="1. 什么是集成学习算法？"></a>1. 什么是集成学习算法？</h4><p>集成学习算法本身不算一种单独的机器学习算法，而是通过构建并结合多个机器学习来完成学习任务。可以说是集百家之所长，能在机器学习算法中拥有较高的准确率，不足之处就是模型的训练过程可能比较复杂，效率不是很高。</p><p><strong>目前常见的集成学习算法主要有2种：基于Bagging的算法和基于Boosting的算法，</strong> 基于Bagging的代表算法有随机森林，而基于Boosting的代表算法则有Adaboost、GBDT、XGBOOST等。</p><h4 id="2-集成学习主要有哪些框架？"><a href="#2-集成学习主要有哪些框架？" class="headerlink" title="2. 集成学习主要有哪些框架？"></a>2. 集成学习主要有哪些框架？</h4><p>Bagging（并行），Boosting（串行）， Stacking</p><h4 id="3-常用的bagging（Boostrap-Agregation）算法有哪些？"><a href="#3-常用的bagging（Boostrap-Agregation）算法有哪些？" class="headerlink" title="3. 常用的bagging（Boostrap Agregation）算法有哪些？"></a>3. 常用的bagging（Boostrap Agregation）算法有哪些？</h4><p>多次采样（bootstrap （有放回的随机抽样）每次从训练集中抽取一个固定大小的训练集A,随机重抽样），训练多个分类器，集体投票，旨在减小方差，防止过拟合。</p><p>如果是<strong>分类</strong>算法预测，则T个弱学习器<strong>投出最多票数</strong>的类别或者类别之一为最终类别。如果是<strong>回归</strong>算法，T个弱学习器得到的回归结果进行<strong>算术平均</strong>得到的值为最终的模型输出。常用bagging算法：<strong>随机森林</strong>算法。</p><h4 id="4-常用的Boosting算法有哪些？"><a href="#4-常用的Boosting算法有哪些？" class="headerlink" title="4. 常用的Boosting算法有哪些？"></a>4. 常用的Boosting算法有哪些？</h4><p>基分类器层层叠加，聚焦分错的样本，旨在减小方差。</p><p>Boosting的主要思想：<strong>迭代式学习。</strong>  </p><p>AdaBoost，GBDT，XGBoost都属于Boosting思想。</p><p><strong>涉及到两个部分，加法模型和前向分步算法。</strong><br>加法模型就是说强分类器由一系列弱分类器线性相加而成。<br>前向分步就是说在训练过程中，下一轮迭代产生的分类器是在上一轮的基础上训练得来的。</p><p>Boosting是一种与Bagging很类似的技术。它的基本原理：先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，<strong>提高被错误分类的样本的权重</strong>，<strong>降低被正确分类的样本的权重</strong>，<strong>使得先前基学习器做错的训练样本在后续受到更多的关注</strong>，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直至基学习器数目达到事先指定的值T，最后将这T个基学习器进行加权结合。</p><p>目标：减少模型的bias，提高预测准确性<br>流程：1、给定初始训练数据，由此训练出第一个基学习器；2、根据基学习器的表现对样本进行调整，在之前学习器做错的样本上投入更多关注；3、用调整后的样本，训练下一个基学习器；4、重复上述过程T次，将T个学习器加权结合</p><h4 id="5-常用的stacking算法有哪些？"><a href="#5-常用的stacking算法有哪些？" class="headerlink" title="5. 常用的stacking算法有哪些？"></a>5. 常用的stacking算法有哪些？</h4><p><strong>多次采样，训练多个分类器，将输出作为最后的输入特征,</strong> 由k-NN、随机森林和朴素贝叶斯基础分类器组成，它的预测结果由作为元分类器的Logistic 回归组合。</p><p>基模型 —&gt; 新的特征集 —&gt; 元模型（使用基模型的预测结果作为输入，并学习如何最佳地组合这些预测结果来给出最终的预测）—&gt; 最终预测</p><h3 id="七-随机森林"><a href="#七-随机森林" class="headerlink" title="七.  随机森林"></a>七.  随机森林</h3><h4 id="1-简述随机森林算法原理"><a href="#1-简述随机森林算法原理" class="headerlink" title="1. 简述随机森林算法原理"></a>1. 简述随机森林算法原理</h4><p>随机森林是一种以决策树（<strong>分类树或者回归树都可以</strong>）为基分类器的集成算法，通过组合多棵独立的决策树后根据<strong>投票或取均值</strong>的方式得到最终预测结果的机器学习方法。</p><ul><li>一个样本容量为N的样本，有放回的抽取N次，每次抽取1个，最终形成了N个样本。这选择好了的N个样本用来训练一个决策树，作为决策树根节点处的样本。</li><li>当每个样本有M个属性时，在决策树的每个节点需要分裂时，随机从这M个属性中选取出m个属性，满足条件m &lt;&lt; M。然后从这m个属性中采用某种策略（比如说信息增益）来选择1个属性作为该节点的分裂属性。</li><li>决策树形成过程中每个节点都要按照步骤2来分裂（很容易理解，如果下一次该节点选出来的那一个属性是刚刚其父节点分裂时用过的属性，则该节点已经达到了叶子节点，无须继续分裂了）。一直到不能够再分裂为止。注意整个决策树形成过程中没有进行剪枝。</li><li>按照步骤1~3建立大量的决策树，这样就构成了随机森林了。</li><li>多数投票机制进行预测。（<strong>分类用投票，回归用均值</strong>）</li></ul><h4 id="2-随机森林的随机性体现在哪？"><a href="#2-随机森林的随机性体现在哪？" class="headerlink" title="2. 随机森林的随机性体现在哪？"></a>2. 随机森林的随机性体现在哪？</h4><p>随机森林的随机性体现在每颗树的<strong>训练样本是随机的</strong>，树中每个节点的分裂属性集合也是随机选择确定的。有了这2个随机的保证，随机森林就不会产生过拟合的现象了。</p><h4 id="3-随机森林算法的优缺点"><a href="#3-随机森林算法的优缺点" class="headerlink" title="3. 随机森林算法的优缺点"></a>3. 随机森林算法的优缺点</h4><p>优点：它能够处理很高维度的数据，并且不用做特征选择，因为特征子集是随机选择的；训练时树与树之间是相互独立的，训练速度快，容易做成并行化方法；对缺失值不敏感，如果有很大一部分的特征遗失，仍可以维持准确度。</p><p>缺点：随机森林在某些噪音较大的分类或回归问题上会过拟合；对于有不同取值的属性的数据，取值划分较多的属性会对随机森林产生更大的影响</p><h4 id="4-随机森林为什么不能用全样本去训练m棵决策树？"><a href="#4-随机森林为什么不能用全样本去训练m棵决策树？" class="headerlink" title="4. 随机森林为什么不能用全样本去训练m棵决策树？"></a>4. 随机森林为什么不能用全样本去训练m棵决策树？</h4><p>全样本训练忽视了局部样本的规律，对于模型的泛化能力是有害的（如果有m个决策树，那就需要m个一定数量的样本集来训练每一棵树）</p><h4 id="5-随机森林和GBDT的区别"><a href="#5-随机森林和GBDT的区别" class="headerlink" title="5. 随机森林和GBDT的区别"></a>5. 随机森林和GBDT的区别</h4><p>组成<strong>随机森林</strong>的树可以是分类树，也可以是回归树；而<strong>GBDT</strong>只能由回归树组成。 组成<strong>随机森林</strong>的树可以并行生成；而<strong>GBDT</strong>只能是串行生成。 对于最终的输出结果而言，<strong>随机森林</strong>采用多数投票等；而<strong>GBDT</strong>则是将所有结果累加起来，或者加权累加起来。</p><h3 id="八-Adaboost（自适应增强）"><a href="#八-Adaboost（自适应增强）" class="headerlink" title="八. Adaboost（自适应增强）"></a>八. Adaboost（自适应增强）</h3><h4 id="1-简述Adaboost原理"><a href="#1-简述Adaboost原理" class="headerlink" title="1. 简述Adaboost原理"></a>1. 简述Adaboost原理</h4><p>它的自适应在于：前一个基本分类器被错误分类的样本的权值会增大，而正确分类的样本的权值会减小，并再次用来训练下一个基本分类器。同时，在每一轮迭代中，加入一个新的弱分类器，直到达到某个预定的足够小的错误率或达到预先指定的最大迭代次数才确定最终的强分类器。</p><h4 id="2-Adaboost常用的损失函数有哪些？"><a href="#2-Adaboost常用的损失函数有哪些？" class="headerlink" title="2. Adaboost常用的损失函数有哪些？"></a>2. Adaboost常用的损失函数有哪些？</h4><p>指数损失</p><p>对于二分类问题，假设有样本 $(x_i, y_i)$，其中 $x_i$​ 是输入特征，$y_i$​ 是标签，通常取值为$y_i \in {-1, +1}$$。假设模型的输出是 f(x_i)$，那么指数损失定义为：<br>$$\large L(y_i, f(x_i)) &#x3D; e^{-y_if(x_i)}$$<br>其中：</p><ul><li>如果样本 $(x_i, y_i)$ 被正确分类，即 $y_i f(x_i) &gt; 0$，损失较小；</li><li>如果样本 $(x_i, y_i)$  被错误分类，即 $y_i f(x_i) &lt; 0$，损失会非常大。</li></ul><h4 id="3-Adaboost如何用于分类？"><a href="#3-Adaboost如何用于分类？" class="headerlink" title="3. Adaboost如何用于分类？"></a>3. Adaboost如何用于分类？</h4><p>步骤：</p><ul><li>计算样本权重：训练数据中的每个样本，赋予其权重，即样本权重，用向量D表示，这些权重都初始化成相等值。假设有n个样本的训练集，设定每个样本的权重都是相等的，即1&#x2F;n。</li><li>计算错误率：利用第一个弱学习算法h1对其进行学习，学习完成后进行错误率的统计</li><li>计算弱学习算法权重：弱学习算法也有一个权重，用向量α表示，利用错误率计算权重α：  α&gt;0，错误率&lt;0.5, 错误率越小，α越大。错误率&#x3D;0.5，α&#x3D;1；α&lt;0:错误率很大</li><li>更新样本权重：在第一次学习完成后，需要重新调整样本的权重，以使得在第一分类中被错分的样本的权重，在接下来的学习中可以重点对其进行学习；其中，h（xi）&#x3D;yi表示对第i个样本训练正确，不等于则表示分类错误。Z是一个归一化因子：Zt&#x3D;sum(D)</li><li>重复进行学习：这样经过t轮的学习后，就会得到t个弱学习算法、权重、弱分类器的输出以及最终的AdaBoost算法的输出：H(X)&gt;0 是1类；H(X)&lt;0 是-1类</li></ul><h4 id="4-Adaboost算法的优缺点？"><a href="#4-Adaboost算法的优缺点？" class="headerlink" title="4. Adaboost算法的优缺点？"></a>4. Adaboost算法的优缺点？</h4><p>优点：无需对弱分类器进行过度优化 不容易过拟合<br>缺点：对噪声敏感，需要强分类能力的弱分类器 对类别不平衡数据敏感</p><h3 id="九-GBDT"><a href="#九-GBDT" class="headerlink" title="九. GBDT"></a>九. GBDT</h3><h4 id="1-简述GBDT原理"><a href="#1-简述GBDT原理" class="headerlink" title="1. 简述GBDT原理"></a>1. 简述GBDT原理</h4><p>DT - Decision Tree决策树，GB是Gradient Boosting，是一种学习策略，GBDT的含义就是用Gradient Boosting的策略训练出来的DT模型。</p><p>Gradient Boost Decision Tree。总共构建T棵树，。当构建到第t棵树的时候，需要对前t-1棵树的训练样本分类回归产生的残差进行拟合。每次构建树的方式以及数据集一样，只不过拟合的目标变成了t-1棵树输出的残差。也就是说，这棵新树要学习如何去“纠正”之前t-1棵树的错误。不可并行化处理。GBDT是一种boosting算法。</p><p><strong>GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差</strong>，这个<strong>残差就是一个加预测值后能得真实值的累加量</strong>。比如A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学。</p><h4 id="2-GBDT常用的损失函数有哪些？"><a href="#2-GBDT常用的损失函数有哪些？" class="headerlink" title="2. GBDT常用的损失函数有哪些？"></a>2. GBDT常用的损失函数有哪些？</h4><p>回归任务：</p><ol><li><p>MAE (mean absolute error) 对异常值不敏感<br>$$\large L(y,\hat{y}) &#x3D; \frac{1}{n}\sum_{i&#x3D;1}^{n}|y_i-\hat{y}_i|$$</p></li><li><p>MSE（mean squared error) 对大误差敏感<br>$$\large L(y,\hat{y}) &#x3D; \frac{1}{n}\sum_{i&#x3D;1}^{n}(y_i-\hat{y}_i)^2$$</p></li><li><p>RMSE（root mean squared error）<br>$$\large L(y,\hat{y}) &#x3D; \sqrt{\frac{1}{n}\sum_{i&#x3D;1}^{n}(y_i-\hat{y}_i)^2}$$</p></li></ol><p>分类任务：</p><ol><li><p>对数损失（logarithmic loss）：<br>$$\large L(y,\hat{y}) &#x3D; -\frac{1}{n}\sum_{i&#x3D;1}^{n}[y_ilog(\hat{y}_i)+(1-y_i)log(1-\hat{y}_i)]$$<br>对数损失（也称为二元交叉熵损失）用于二分类问题。</p></li><li><p>指数损失（exponential loss）：<br>$$\large L(y,\hat{y}) &#x3D; exp(-y \cdot \hat{y})$$<br>指数损失是AdaBoost算法使用的损失函数，它倾向于更强烈地惩罚错误分类，导致模型更加注重难分类的样本。</p></li></ol><h4 id="3-GBDT如何用于分类"><a href="#3-GBDT如何用于分类" class="headerlink" title="3. GBDT如何用于分类"></a>3. GBDT如何用于分类</h4><p>与回归任务类似，不同的是损失函数不同。</p><h4 id="4-GBDT算法的优缺点？"><a href="#4-GBDT算法的优缺点？" class="headerlink" title="4. GBDT算法的优缺点？"></a>4. GBDT算法的优缺点？</h4><p>优点：</p><ol><li>高精度</li><li>灵活：可应用于多种类型的数据</li><li>无需特征归一化，对特征的尺度不敏感</li></ol><p>缺点：</p><ol><li>无法并行，计算时间长</li><li>难以处理高维稀疏数据</li></ol><h3 id="十-XGBoost"><a href="#十-XGBoost" class="headerlink" title="十.  XGBoost"></a>十.  XGBoost</h3><h4 id="1-简述XGBoost"><a href="#1-简述XGBoost" class="headerlink" title="1. 简述XGBoost"></a>1. 简述XGBoost</h4><p>总共构建T颗树。当构建到第t颗树的时候，需要对前t-1颗树对训练样本分类回归产生的残差进行拟合。每次拟合产生新的树的时候，遍历所有可能的树，并选择使得目标函数值（cost）最小的树。但是这样在实践中难以实现，因此需要将步骤进行分解，在构造新的树的时候，每次只产生一个分支，并选择最好的那个分支。如果产生分支的目标函数值（cost）比不产生的时候大或者改进效果不明显，那么就放弃产生分支（相当于truncate，截断）。可以并行化处理，效率比GBDT高，效果比GBDT好。XGBoost是一种boosting算法。</p><h4 id="2-XGBoost和GBDT有什么不同？"><a href="#2-XGBoost和GBDT有什么不同？" class="headerlink" title="2. XGBoost和GBDT有什么不同？"></a>2. XGBoost和GBDT有什么不同？</h4><ol><li>在XGBoost中，特征分裂的计算可以并行进行</li><li>传统的GBDT通常没有在目标函数中显式加入正则化项，仅通过调节参数（如树的深度、学习率、树的数量等）来控制模型的复杂度。XGBoost在目标函数中引入了正则化项（L1和L2正则化），直接对模型的复杂度进行惩罚。</li><li>传统的GBDT算法通常只使用损失函数的一阶导数（梯度）来指导模型的更新。XGBoost不仅利用了一阶导数（梯度），还使用了损失函数的二阶导数（Hessian矩阵）。</li><li></li></ol><ul><li><strong>GBDT</strong>：GBDT在每次构建树时，按照增益选择最佳分裂点，构建完整的树结构，并在需要时进行预剪枝（Pre-pruning），即限制树的深度或叶子节点数量以控制模型复杂度。</li><li><strong>XGBoost</strong>：XGBoost首先构建一棵完整的树，然后从叶子节点开始向上进行后剪枝（Post-pruning）。这意味着在构建树的过程中，XGBoost能够根据增益来决定是否保留某个分裂节点，进一步减少过拟合的风险。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一-特征工程&quot;&gt;&lt;a href=&quot;#一-特征工程&quot; class=&quot;headerlink&quot; title=&quot;一. 特征工程&quot;&gt;&lt;/a&gt;一. 特征工程&lt;/h3&gt;&lt;h4 id=&quot;1-为什么要对特征做归一化处理&quot;&gt;&lt;a href=&quot;#1-为什么要对特征做归一化处理&quot; cla</summary>
      
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>python考点</title>
    <link href="http://example.com/2024/10/10/python%E8%80%83%E7%82%B9/"/>
    <id>http://example.com/2024/10/10/python%E8%80%83%E7%82%B9/</id>
    <published>2024-10-10T15:02:56.000Z</published>
    <updated>2024-10-10T15:19:10.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-解释性语言-编译性语言"><a href="#1-解释性语言-编译性语言" class="headerlink" title="1.  解释性语言 &#x2F; 编译性语言"></a>1.  解释性语言 &#x2F; 编译性语言</h3><ul><li>编译性语言：把做好的源程序全部编译成<strong>二进制</strong>的可运行程序，然后运行，如C，C++</li><li>解释性语言：把做好的源程序翻译一句，执行一句，直至结束，如Python</li></ul><p>注意：Java 有些特殊，java程序也需要编译，但是没有直接编译成为机器语言，而是编译称为<strong>字节码</strong>，然后用<strong>解释方式</strong>执行字节码。</p><h3 id="2-简述下Python中的字符串，列表，元组和字典"><a href="#2-简述下Python中的字符串，列表，元组和字典" class="headerlink" title="2.  简述下Python中的字符串，列表，元组和字典"></a>2.  简述下Python中的字符串，列表，元组和字典</h3><ul><li>字符串（str）：字符串是用引号括起来的任意文本，是编程语言中最常用的数据类型。</li><li>列表（list）：列表是<strong>有序</strong>的集合，可以向其中添加或删除元素</li><li>元组（tuple）：元组也是<strong>有序</strong>集合，元组中的数无法修改，<strong>不可变</strong></li><li>字典（dict）：字典是<strong>无序</strong>集合，是由<strong>键值对</strong>（key-value）组成的</li><li>集合（set）：是一组key的集合，每个元素是<strong>唯一</strong>，<strong>不重复</strong>且<strong>无序</strong>的</li></ul><h3 id="3-简述上述数据类型的常用方法"><a href="#3-简述上述数据类型的常用方法" class="headerlink" title="3. 简述上述数据类型的常用方法"></a>3. 简述上述数据类型的常用方法</h3><p>字符串：</p><ul><li>切片：<code>&#39;luobodazahui&#39;[1:3]</code></li><li>format：<code>&quot;welcome to luobodazahui, dear &#123;name&#125;&quot;format(name=&quot;baby&quot;)</code></li><li>join：可以用来连接字符串，将字符串，元组，列表中的元素以指定的字符（分隔符）连接生成一个新的字符串。<code>&#39;&#39;.join([&#39;luo&#39;, &#39;bo&#39;, &#39;da&#39;, &#39;za&#39;, &#39;hui&#39;])</code></li><li><code>String.replace(old,new,count)</code>：将字符串中的 <code>old</code>字符替换为 <code>New</code>字符，<code>count</code>为替换的个数 <code>&#39;luobodazahui-haha&#39;.replace(&#39;haha&#39;, &#39;good&#39;)</code></li><li>split：切割字符串，得到一个列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mystr5 = <span class="string">&#x27;luobo,dazahui good&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(mystr5.split())  <span class="comment"># 默认以空格分割</span></span><br><span class="line">[<span class="string">&#x27;luobo,dazahui&#x27;</span>, <span class="string">&#x27;good&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(mystr5.split(<span class="string">&#x27;h&#x27;</span>))  <span class="comment"># 以h分割</span></span><br><span class="line">[<span class="string">&#x27;luobo,daza&#x27;</span>, <span class="string">&#x27;ui good&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(mystr5.split(<span class="string">&#x27;,&#x27;</span>))  <span class="comment"># 以逗号分割</span></span><br><span class="line">[<span class="string">&#x27;luobo&#x27;</span>, <span class="string">&#x27;dazahui good&#x27;</span>]</span><br></pre></td></tr></table></figure><p>列表：</p><ul><li>切片，同字符串</li><li>append和extend向列表中添加元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist3 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist1.append(mylist2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(mylist1)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist3.extend(mylist2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(mylist3)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><ul><li><p>删除元素：</p><ul><li>del：根据下标进行删除</li><li>pop：删除最后一个元素</li><li>remove：根据元素的值进行删除</li></ul></li><li><p>元素排序sort：是将list按特定顺序重新排列，默认为由小到大，参数reverse &#x3D; True 可改为倒序，由大到小。</p></li><li><p>reverse：是将list逆置</p></li></ul><p>字典：</p><ul><li>清空字典：dict.clear()</li><li>指定删除：使用pop方法来指定删除字典中的某一项。</li><li>遍历字典 values&#x2F;items</li><li><code>fromkeys</code>用于创建一个新字典，以序列中元素做字典的键，<code>value</code>为字典所有键对应的初始值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys = [<span class="string">&#x27;zhangfei&#x27;</span>, <span class="string">&#x27;guanyu&#x27;</span>, <span class="string">&#x27;liubei&#x27;</span>, <span class="string">&#x27;zhaoyun&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>.fromkeys(keys, <span class="number">0</span>)</span><br><span class="line">&#123;<span class="string">&#x27;zhangfei&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;guanyu&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;liubei&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;zhaoyun&#x27;</span>: <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-简述Python中的字符串编码"><a href="#4-简述Python中的字符串编码" class="headerlink" title="4. 简述Python中的字符串编码"></a>4. 简述Python中的字符串编码</h3><p>当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。<strong>UTF-8是隶属于Unicode的可变长的编码方式</strong>。在Python中，以Unicode方式编码的字符串，可以使用encode( )方法来编码成指定的bytes，也可以通过decode( )方法来把bytes编码成字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;你好&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="string">&quot;你好&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-is和-的区别"><a href="#5-is和-的区别" class="headerlink" title="5. is和=&#x3D;的区别"></a>5. is和=&#x3D;的区别</h3><p>=&#x3D; 是操作比较符，只是判断对象的<strong>值（value）</strong> 是否一致，而is则判断的是对象之间的身份（<strong>内存地址</strong>）是否一致。对象的身份，可以通过id( )方法来查看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = d = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(c <span class="keyword">is</span> d)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(c == d)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(c <span class="keyword">is</span> e)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(c == e)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>只有 <code>id</code>一致时，<code>is</code>比较才会返回 <code>True</code>，而当 <code>value</code>一致时，<code>==</code> 比较就会返回 <code>True</code>。</p><h3 id="6-Python函数中的参数类型"><a href="#6-Python函数中的参数类型" class="headerlink" title="6. Python函数中的参数类型"></a>6. Python函数中的参数类型</h3><ul><li>位置函数：函数的参数列表中定义x个位置参数，函数调用时就必须传入x个参数，参数数量必须保持一致。</li><li>默认参数：调用函数时可省略参数 （设置一个默认值）</li><li>可变参数：最常见的变量名是args，看到该变量名，一眼就知道变量args指向一个tuple对象。kwargs，看到该变量名，一眼就知道变量kwargs指向一个dict对象</li><li>关键字参数：函数调用时，指定参数名称，称为关键字参数（别和默认参数混淆，这里是函数调用）</li></ul><h3 id="7-args-和-kwarg-作用"><a href="#7-args-和-kwarg-作用" class="headerlink" title="7. ***args 和 **kwarg 作用"></a>7. ***args 和 **kwarg 作用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">*arg, **kwarg</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> arg:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&quot;arg:&quot;</span>, arg)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> kwarg:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&quot;kwarg:&quot;</span>, kwarg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test(<span class="string">&#x27;ni&#x27;</span>, <span class="string">&#x27;hao&#x27;</span>, key=<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">arg: (<span class="string">&#x27;ni&#x27;</span>, <span class="string">&#x27;hao&#x27;</span>)</span><br><span class="line">kwarg: &#123;<span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;world&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>*arg</code> 会把位置参数转化为 <code>tuple</code>，<code>**kwarg</code> 会把关键字参数转化为 <code>dict</code>。</p><h3 id="8-Python-的深浅拷贝"><a href="#8-Python-的深浅拷贝" class="headerlink" title="8.  Python 的深浅拷贝"></a>8.  Python 的深浅拷贝</h3><p>浅拷贝：<strong>浅拷贝只成功”独立“拷贝了列表的外层，而列表的内层列表，还是共享的</strong>。<br>深拷贝：<strong>深拷贝使得两个列表完全独立开来，每一个列表的操作，都不会影响到另一个</strong>。</p><h3 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">num</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> [<span class="keyword">lambda</span> x:i*x <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m(<span class="number">1</span>) <span class="keyword">for</span> m <span class="keyword">in</span> num()]</span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>i在外层作用域 lambda x: x<em>i  为内层（嵌）函数，他的命名空间中只有 {‘x’: 1} 没有i，所以运行时会向外层函数（这里是列表解析式函数）的命名空间中请求i，而当列表解析式运行时，列表解析式命名空间中的i经过循环依次变化为0–&gt;1–&gt;2–&gt;3最后固定为3，所以当 lambda x: x</em>i内层函数运行时，去外层函数取i每次都只能取到 3。</p><h3 id="10-filter-map-reduce的作用"><a href="#10-filter-map-reduce的作用" class="headerlink" title="10. filter, map, reduce的作用"></a>10. filter, map, reduce的作用</h3><ul><li><p>filter函数用于过滤序列，它接收一个函数和一个序列，把函数作用在序列的每个元素上，然后根据返回值是True还是False决定保留还是丢弃该元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span>, mylist))</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li><li><p>map函数传入一个函数和一个序列，并把函数作用到序列的每个元素上，返回一个可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span>, mylist))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, mylist))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]</span><br></pre></td></tr></table></figure></li><li><p>reduce函数用于递归计算，同样需要传入一个函数和一个序列，并把函数和序列元素的计算结果与下一个元素进行计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x + y, <span class="built_in">range</span>(<span class="number">101</span>))</span><br><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure><p><code>reduce()</code>将一个数据集合（链表，元组等）中的<strong>所有数据</strong>进行下列操作：用传给<code>reduce</code> 中的 <code>function</code>函数 （有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 <code>function</code> 函数运算，最后得到一个结果。</p></li></ul><p>应用：<br>所有元素的乘积：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(<span class="keyword">lambda</span> x, y: x * y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>计算列表中所有元素的最大值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(<span class="keyword">lambda</span> x, y: x <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>有一个列表：<code>[3, 5, 8, 1]</code>对应的是3581的每一个数字，要从这个列表计算出原来的数，可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(<span class="keyword">lambda</span> x, y: x * <span class="number">10</span> + y, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="11-面向对象中-new-和-init-区别"><a href="#11-面向对象中-new-和-init-区别" class="headerlink" title="11. 面向对象中__new__ 和 __init__ 区别"></a>11. 面向对象中<code>__new__</code> 和 <code>__init__</code> 区别</h3><ul><li><code>__new__</code>是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例对象，是个静态方法。</li><li><code>__init__</code>是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候，是一个实例方法。</li><li><code>__new__</code>至少要有一个参数cls，代表当前类，此参数在实例化时由 Python 解释器自动识别。</li><li><code>__new__</code>必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以 return 父类（通过 super(当前类名, cls)）<code>__new__</code>出来的实例，或者直接是 object的__new__出来的实例。</li><li><code>__init__</code> 有一个参数 self，就是这个__new__返回的实例，<code>__init__</code> 在__new__的基础上可以完成一些其它初始化的动作，<code>__init__</code> 不需要返回值。</li><li>如果__new__创建的是当前类的实例，会自动调用__init__函数，通过 return 语句里面调用的__new__函数的第一个参数是 <strong>cls</strong>** 来保证是当前类实例**，如果是其他类的类名，那么实际创建返回的就是其他类的实例，其实就不会调用当前类的__init__函数，也不会调用其他类的__init__函数。</li></ul><h3 id="12-with方法打开文件的使用"><a href="#12-with方法打开文件的使用" class="headerlink" title="12. with方法打开文件的使用"></a>12. with方法打开文件的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="13-字符串转列表-字符串转整数"><a href="#13-字符串转列表-字符串转整数" class="headerlink" title="13. 字符串转列表 &#x2F; 字符串转整数"></a>13. 字符串转列表 &#x2F; 字符串转整数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;1,2,3,4,5,6,7,8,9&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;1,2,3,4,5,6,7,8,9&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x), s.split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="14-二分法"><a href="#14-二分法" class="headerlink" title="14. 二分法"></a>14. 二分法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">data, item</span>):</span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(data) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">mid = (left + right) // <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> data[mid] == item:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">elif</span> data[mid] &lt; item:</span><br><span class="line">left = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">right = mid - <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="15-列表推导式、字典推导式和生成器"><a href="#15-列表推导式、字典推导式和生成器" class="headerlink" title="15. 列表推导式、字典推导式和生成器"></a>15. 列表推导式、字典推导式和生成器</h3><p><strong>列表推导式</strong>：生成一个列表，存储所有的计算结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>td_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>td_list</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(td_list)</span><br><span class="line"><span class="built_in">list</span></span><br></pre></td></tr></table></figure><p><strong>字典推导式</strong>：生成一个字典，根据键值对计算结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;k: <span class="number">2</span> <span class="keyword">for</span> k <span class="keyword">in</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(dic)</span><br><span class="line"><span class="built_in">dict</span></span><br></pre></td></tr></table></figure><p><strong>生成器表达式</strong>：生成一个生成器对象，按需生成数据，节省内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ge_list = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ge_list</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x000001C3C127AAC8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(ge_list)</span><br><span class="line">generator</span><br></pre></td></tr></table></figure><h3 id="16-简述-read、readline、readlines-的区别"><a href="#16-简述-read、readline、readlines-的区别" class="headerlink" title="16.  简述 read、readline、readlines 的区别"></a>16.  简述 read、readline、readlines 的区别</h3><p><strong>read</strong> : 读取整个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()  <span class="comment"># 读取整个文件内容</span></span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p><strong>readline</strong> : 读取文件的一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    line = file.readline()  <span class="comment"># 读取一行内容</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure><p><strong>readlines</strong> : 读取文件的所有行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    lines = file.readlines()  <span class="comment"># 读取所有行</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="17-单下划线和双下划线的作用"><a href="#17-单下划线和双下划线的作用" class="headerlink" title="17. 单下划线和双下划线的作用"></a>17. 单下划线和双下划线的作用</h3><ul><li><strong>单下划线（<code>_var</code>）</strong>：用于表示内部使用，或作为临时变量。</li><li><strong>双下划线前缀（<code>__var</code>）</strong>：用于防止名称冲突，通过名称改编机制实现。</li><li><strong>双下划线前后缀（<code>__var__</code>）</strong>：用于特殊方法和内建方法，遵循 Python 的魔法方法命名约定。</li></ul><h3 id="18-python面向对象中的继承有什么特点"><a href="#18-python面向对象中的继承有什么特点" class="headerlink" title="18. python面向对象中的继承有什么特点"></a>18. python面向对象中的继承有什么特点</h3><ul><li>同时支持单继承与多继承，当只有一个父类时为单继承，当存在多个父类时为多继承；</li><li>子类会继承父类所有的属性和方法，子类也可以覆盖父类同名的变量和方法；</li><li>在继承中基类的构造（<strong>init</strong>()）方法不会被自动调用，它需要在其派生类的构造中专门调用；</li><li>在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别于在类中调用普通函数时并不需要带上 self 参数。</li></ul><h3 id="19-super函数的作用"><a href="#19-super函数的作用" class="headerlink" title="19. super函数的作用"></a>19. super函数的作用</h3><p>调用父类的一个方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">funcA</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is func A&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">funcA_in_B</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(B, <span class="variable language_">self</span>).funcA()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">funcC</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is func C&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ins = B()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ins.funcA_in_B()</span><br><span class="line">this <span class="keyword">is</span> func A</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ins.funcC()</span><br><span class="line">this <span class="keyword">is</span> func C</span><br></pre></td></tr></table></figure><h3 id="20-实例方法、类方法和静态方法。"><a href="#20-实例方法、类方法和静态方法。" class="headerlink" title="20. 实例方法、类方法和静态方法。"></a>20. 实例方法、类方法和静态方法。</h3><ul><li>实例方法<br>定义：第一个参数必须是<strong>实例对象</strong>，该参数名一般约定为“<code>self</code>”，通过它来传递实例的属性和方法（也可以传类的属性和方法）。<br>调用：只能由实例对象调用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">instance_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Value is <span class="subst">&#123;self.value&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.instance_method())  <span class="comment"># 输出: Value is 10</span></span><br></pre></td></tr></table></figure><ul><li>类方法<br>定义：使用装饰器<code>@classmethod</code>。第一个参数必须是当前类对象，该参数名一般约定为“<code>cls</code>”，通过它来传递类的属性和方法（不能传实例的属性和方法）。<br>调用：实例对象和类对象都可以调用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    class_variable = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_method</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Class variable is <span class="subst">&#123;cls.class_variable&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(MyClass.class_method())  <span class="comment"># 输出: Class variable is 0</span></span><br></pre></td></tr></table></figure><ul><li>静态方法<br>定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法。<br>调用：实例对象和类对象都可以调用。</li></ul><p>静态方法是类中的函数，不需要实例。静态方法主要是用来存放逻辑性的代码，主要是一些逻辑属于类，但是和类本身没有交互。即在静态方法中，不会涉及到类中的方法和属性的操作。可以理解为将静态方法存在此类的名称空间中。</p><p>类方法是将类本身作为对象进行操作的方法。他和静态方法的区别在于：不管这个方式是从实例调用还是从类调用，它都用第一个参数把类传递过来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>(<span class="params">param</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Static method received: <span class="subst">&#123;param&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(MyClass.static_method(<span class="string">&#x27;Hello&#x27;</span>))  </span><br><span class="line"><span class="comment"># 输出: Static method received: Hello</span></span><br></pre></td></tr></table></figure><h3 id="21-isinstance-的作用以及与type-的区别"><a href="#21-isinstance-的作用以及与type-的区别" class="headerlink" title="21. isinstance 的作用以及与type()的区别"></a>21. <code>isinstance</code> 的作用以及与<code>type()</code>的区别</h3><ul><li><code>type()</code>不会认为子类是一种父类类型，不考虑继承关系；</li><li><code>isinstance()</code>会认为子类是一种父类类型，考虑继承关系。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = B()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">isinstance</span>(a, A))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(a) == A)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">isinstance</span>(b, A))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(b) == A)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="22-Python中的反射"><a href="#22-Python中的反射" class="headerlink" title="22. Python中的反射"></a>22. Python中的反射</h3><p>反射就是通过字符串的形式，导入模块；通过字符串的形式，去模块寻找指定函数，并执行。利用字符串的形式去对象（模块）中操作（查找&#x2F;获取&#x2F;删除&#x2F;添加）成员，一种<strong>基于字符串的事件驱动</strong>！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, male</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.male = male</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myname</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;My name is <span class="subst">&#123;self.name&#125;</span>&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mymale</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;I am a <span class="subst">&#123;self.male&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>people = NewClass(<span class="string">&#x27;luobo&#x27;</span>, <span class="string">&#x27;boy&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">hasattr</span>(people, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">getattr</span>(people, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">luobo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">setattr</span>(people, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;girl&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">getattr</span>(people, <span class="string">&#x27;male&#x27;</span>))</span><br><span class="line">girl</span><br></pre></td></tr></table></figure><h3 id="23-sort和sorted区别"><a href="#23-sort和sorted区别" class="headerlink" title="23. sort和sorted区别"></a>23. sort和sorted区别</h3><p>sort( )是可变对象列表（list）的方法，会改变原始对象<br>sorted（）是产生一个新的对象，sorted(L)返回一个排序后的L，不改变原始的L，sorted（）适用于任何可迭代容器。</p><h3 id="24-Python多线程"><a href="#24-Python多线程" class="headerlink" title="24. Python多线程"></a>24. Python多线程</h3><p>GIL 是 Python 的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行 Python 程序的时候会占用 Python 解释器（加了一把锁即 GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。</p><h3 id="25-简述any（）和all（）方法"><a href="#25-简述any（）和all（）方法" class="headerlink" title="25. 简述any（）和all（）方法"></a>25. 简述any（）和all（）方法</h3><p><code>all</code>：如果存在 <code>0</code>，<code>None</code>，<code>False</code> 返回 False，否则返回 <code>True</code>；<br><code>any</code>：如果都是 <code>0</code>，<code>None</code>，<code>False</code>时，返回 <code>False</code>。</p><h3 id="26-简述闭包"><a href="#26-简述闭包" class="headerlink" title="26. 简述闭包"></a>26. 简述闭包</h3><p>闭包指的是满足以下几个条件的函数：</p><ol><li>必须有一个内嵌函数。</li><li>内嵌函数必须引用外部函数中的变量。</li><li>外部函数的返回值必须是内嵌函数。</li></ol><h3 id="27-装饰器"><a href="#27-装饰器" class="headerlink" title="27. 装饰器"></a>27. 装饰器</h3><p><strong>装饰器是一种特殊的闭包</strong>，就是<strong>在闭包的基础上传递了一个函数</strong>，然后<strong>覆盖原来函数的执行入口</strong>，以后调用这个函数的时候，就可以额外实现一些功能了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_decorator</span>(<span class="params">func</span>):    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapper</span>():        </span><br><span class="line">start_time = time.time()        </span><br><span class="line">func()        </span><br><span class="line">end_time = time.time()        </span><br><span class="line">execution_time = end_time - start_time        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Function <span class="subst">&#123;func.__name__&#125;</span> executed in <span class="subst">&#123;execution_time&#125;</span> seconds&quot;</span>)    </span><br><span class="line"><span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():    </span><br><span class="line">time.sleep(<span class="number">1</span>)    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure><p>实际上等于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_decorator(say_hello)</span><br></pre></td></tr></table></figure><h3 id="28-yield用法"><a href="#28-yield用法" class="headerlink" title="28. yield用法"></a>28. yield用法</h3><p><code>yield</code> 是用来生成迭代器的语法，在函数中，如果包含了 <code>yield</code>，那么这个函数就是一个迭代器。当代码执行至 <code>yield</code> 时，就会中断代码执行，直到程序调用 <code>next()</code> 函数时，才会在上次 <code>yield</code> 的地方继续执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-解释性语言-编译性语言&quot;&gt;&lt;a href=&quot;#1-解释性语言-编译性语言&quot; class=&quot;headerlink&quot; title=&quot;1.  解释性语言 &amp;#x2F; 编译性语言&quot;&gt;&lt;/a&gt;1.  解释性语言 &amp;#x2F; 编译性语言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;编译</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
